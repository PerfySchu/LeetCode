## 基本分析

一个基本的实现，需要满足除构造函数以外复杂度为 $O(k)$ 以外，其余操作均为 $O(1)$。

常规实现包含两种方式：**数组实现** 与 **链表实现**。

其中数组实现可以利用调用次数较小，开成调用次数 $3$ 倍大小，然后从中间开始往两边存储，这样做就不用考虑下标边的界问题；而更为常规的解法是构造一个与限定空间 $k$ 等大的数组，使用两下标并配合坐标转换来做，对于下标自增操作而言，只需要进行「加一取模」即可，而对于下标自减操作，由于考虑负值问题，需要进行「增加限定空间偏移后，进行减一再取模」。

而链表实现则无须考虑额外的下标转换问题，但需要额外定义类。

---

## 数组

使用两坐标 `he` 和 `ta` 分别代表队列头和尾（初始值均为 $0$），使用 `cnt` 记录当前队列元素大小，使用 `k` 记录初始化时指定的空间大小。

对各类操作进行逻辑控制：

* `insertFront` 操作：需要对 `he` 进行自减操作，即 `he = (he + k - 1) % k` 为目标位置，同时对 `cnt` 进行自增；
* `insertLast` 操作：需要对 `ta` 进行自增操作，但 `ta` 起始指向是待插入位置，因此 `ta` 为目标位置，随后更新 `ta = (ta + 1) % k`，同时对 `cnt` 进行自增；
* `deleteFront` 操作：需要对 `he` 进行自增操作，直接更新 `he = (he + 1) % k`，同时更新 `cnt` 进行自减；
* `deleteLast` 操作：需要对 `ta` 进行自减操作，更新 `ta = (ta + k - 1) % k`，同时更新 `cnt` 进行自减；
* `getFront` 操作：返回 `nums[he]` 即可， 若 `isFull` 为 `True`，返回 `-1`；
* `getRear` 操作：返回 `nums[ta - 1]`，由于存在负值问题，需要转换为返回 `nums[(ta + k - 1) % k]` 若 `isFull` 为 `True`，返回 `-1`；
* `isEmpty` 操作：根据 `cnt` 与 `k` 的关系进行返回；
* `isFull` 操作：根据 `cnt` 与 `k` 的关系进行返回；

代码：

* []

```Java
class MyCircularDeque {
    int[] nums;
    int he, ta, cnt, k;
    public MyCircularDeque(int _k) {
        k = _k;
        nums = new int[k];
    }
    public boolean insertFront(int value) {
        if (isFull()) return false;
        he = (he + k - 1) % k;
        nums[he] = value; cnt++;
        return true;
    }
    public boolean insertLast(int value) {
        if (isFull()) return false;
        nums[ta++] = value; cnt++;
        ta %= k;
        return true;
    }
    public boolean deleteFront() {
        if (isEmpty()) return false;
        he = (he + 1) % k; cnt--;
        return true;
    }
    public boolean deleteLast() {
        if (isEmpty()) return false;
        ta = (ta + k - 1) % k; cnt--;
        return true;
    }
    public int getFront() {
        return isEmpty() ? -1 : nums[he];
    }
    public int getRear() {
        return isEmpty() ? -1 : nums[(ta + k - 1) % k];
    }
    public boolean isEmpty() {
        return cnt == 0;
    }
    public boolean isFull() {
        return cnt == k;
    }
}
```

* []

```TypeScript
class MyCircularDeque {
    he = 0; ta = 0; cnt = 0; k = 0;
    nums: number[];
    constructor(_k: number) {
        this.k = _k
        this.he = this.ta = this.cnt = 0
        this.nums = new Array<number>(this.k)
    }
    insertFront(value: number): boolean {
        if (this.isFull()) return false
        this.he = (this.he + this.k - 1) % this.k
        this.nums[this.he] = value
        this.cnt++
        return true
    }
    insertLast(value: number): boolean {
        if (this.isFull()) return false
        this.nums[this.ta++] = value
        this.ta %= this.k
        this.cnt++
        return true
    }
    deleteFront(): boolean {
        if (this.isEmpty()) return false
        this.he = (this.he + 1) % this.k
        this.cnt--
        return true
    }
    deleteLast(): boolean {
        if (this.isEmpty()) return false
        this.ta = (this.ta + this.k - 1) % this.k
        this.cnt--
        return true
    }
    getFront(): number {
        return this.isEmpty() ? -1 : this.nums[this.he]
    }
    getRear(): number {
        return this.isEmpty() ? -1 : this.nums[(this.ta + this.k - 1) % this.k]
    }
    isEmpty(): boolean {
        return this.cnt == 0
    }
    isFull(): boolean {
        return this.cnt == this.k
    }
}
```

* 时间复杂度：除在初始化函数中构造容器复杂度为 $O(k)$ 以外，其余操作复杂度均为 $O(1)$
* 空间复杂度：$O(n)$

---

## 链表

创建 `Node` 代指每个操作的元素，使用双向链表来构造循环队列。

各类操作均对应基本的链表操作，不再赘述。

代码：

* []

```Java
class MyCircularDeque {
    class Node {
        Node prev, next;
        int val;
        Node (int _val) {
            val = _val;
        }
    }
    int cnt, k;
    Node he, ta;
    public MyCircularDeque(int _k) {
        k = _k;
        he = new Node(-1); ta = new Node(-1);
        he.next = ta; ta.prev = he;
    }
    public boolean insertFront(int value) {
        if (isFull()) return false;
        Node node = new Node(value);
        node.next = he.next;
        node.prev = he;
        he.next.prev = node;
        he.next = node;
        cnt++;
        return true;
    }
    public boolean insertLast(int value) {
        if (isFull()) return false;
        Node node = new Node(value);
        node.next = ta;
        node.prev = ta.prev;
        ta.prev.next = node;
        ta.prev = node;
        cnt++;
        return true;
    }
    public boolean deleteFront() {
        if (isEmpty()) return false;
        he.next.next.prev = he;
        he.next = he.next.next;
        cnt--;
        return true;
    }
    public boolean deleteLast() {
        if (isEmpty()) return false;
        ta.prev.prev.next = ta;
        ta.prev = ta.prev.prev;
        cnt--;
        return true;
    }
    public int getFront() {
        return isEmpty() ? -1 : he.next.val;
    }
    public int getRear() {
        return isEmpty() ? -1 : ta.prev.val;
    }
    public boolean isEmpty() {
        return cnt == 0;
    }
    public boolean isFull() {
        return cnt == k;
    }
}
```

* []

```TypeScript
class TNode {
    prev: TNode = null; next: TNode = null;
    val: number = 0;
    constructor(_val: number) {
        this.val = _val
    }
}
class MyCircularDeque {
    he = null; ta = null;
    cnt = 0; k = 0;
    constructor(_k: number) {
        this.cnt = 0; this.k = _k;
        this.he = new TNode(-1); this.ta = new TNode(-1);
        this.he.next = this.ta
        this.ta.prev = this.he
    }
    insertFront(value: number): boolean {
        if (this.isFull()) return false
        const node = new TNode(value)
        node.next = this.he.next
        node.prev = this.he
        this.he.next.prev = node
        this.he.next = node
        this.cnt++
        return true
    }
    insertLast(value: number): boolean {
        if (this.isFull()) return false
        const node = new TNode(value)
        node.next = this.ta
        node.prev = this.ta.prev
        this.ta.prev.next = node
        this.ta.prev = node
        this.cnt++
        return true
    }
    deleteFront(): boolean {
        if (this.isEmpty()) return false
        this.he.next.next.prev = this.he
        this.he.next = this.he.next.next
        this.cnt--
        return true
    }
    deleteLast(): boolean {
        if (this.isEmpty()) return false
        this.ta.prev.prev.next = this.ta
        this.ta.prev = this.ta.prev.prev
        this.cnt--
        return true
    }
    getFront(): number {
        return this.isEmpty() ? -1 : this.he.next.val
    }
    getRear(): number {
        return this.isEmpty() ? -1 : this.ta.prev.val
    }
    isEmpty(): boolean {
        return this.cnt == 0
    }
    isFull(): boolean {
        return this.cnt == this.k
    }
}
```

* 时间复杂度：所有操作复杂度均为 $O(1)$
* 空间复杂度：$O(n)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
